#!perl

use strict;
use warnings;
use Getopt::Long;
use Virani;
use TOML;
use File::Slurp;
use Time::Piece::Guess;
use Virani::Client;
use JSON;

sub version {
	print "viarni v. 0.0.1\n";
}

sub help {
	&version;

	print '
';
}

# get the cli optiosn
my $help    = 0;
my $version = 0;
my $filter  = undef;
my $start;
my $end;
my $write = 'out.pcap';
my $format;
my $remote;
my $url;
my $apikey;
my $set           = 'default';
my $config_virani = '/usr/local/etc/virani.toml';
my $tmpdir;
my $no_cache             = 0;
my $quiet                = 0, my $verbose = 1;
my $type                 = 'tcpdump';
my $verify_hostname      = 1;
my $verify_hostname_flag = 0;
Getopt::Long::Configure('no_ignore_case');
Getopt::Long::Configure('bundling');
GetOptions(
	'version'  => \$version,
	'v'        => \$version,
	'help'     => \$help,
	'h'        => \$help,
	'f=s'      => \$filter,
	's=s'      => \$start,
	'e=s'      => \$end,
	'w=s'      => \$write,
	'r=s'      => \$remote,
	'set=s'    => \$set,
	'nc'       => \$no_cache,
	'q'        => \$quiet,
	'config=s' => \$config_virani,
	'a=s'      => \$apikey,
	't=s'      => \$type,
	'k'        => \$verify_hostname_flag,
);

if ( !defined($start) ) {
	die('No start time set via -s');
}
elsif ( !defined($end) ) {
	die('No start time set via -s');
}

if ($quiet) {
	$verbose = 0;
}

if ($verify_hostname_flag) {
	$verify_hostname = 0;
}

my $start_obj;
eval { $start_obj = Time::Piece::Guess->guess_to_object($start); };
if ( $@ || !defined($start_obj) ) {
	die( 'Failed to parse the start stamp,"' . $start . '",' );
}
my $end_obj;
eval { $end_obj = Time::Piece::Guess->guess_to_object($end); };
if ( $@ || !defined($end_obj) ) {
	die( 'Failed to parse the end timestamp,"' . $end . '",' );
}

# handles it if it is not remote
if ( !$remote ) {
	my $virani = Virani->new_from_conf( conf => $config_virani );
	$virani->set_verbose($verbose);
	$virani->set_verbose_to_syslog(0);

	my $returned = $virani->get_pcap_local(
		start    => $start_obj,
		end      => $end_obj,
		filter   => $filter,
		file     => $write,
		no_cache => $no_cache,
		verbose  => $verbose,
		set      => $set,
		type     => $type,
	);
	if ( $returned->{using_cache} ) {
		my $json = JSON->new->allow_nonref->pretty->canonical(1);
		print "Cache metadata...\n" . $json->encode($returned);
	}

	exit 0;
}
else {
	# check to see if remote is a config file
	my $config_file;
	if ( -f $remote ) {
		$config_file = $remote;
	}
	elsif ( -f $remote . '.toml' ) {
		$config_file = $remote . '.toml';
	}
	elsif ( -f '/usr/local/etc/virani.d/' . $remote ) {
		$config_file = '/usr/local/etc/virani.d/' . $remote;
	}
	elsif ( -f '/usr/local/etc/virani.d/' . $remote . '.toml' ) {
		$config_file = '/usr/local/etc/virani.d/' . $remote . '.toml';
	}
	elsif ( -f '/etc/virani.d/' . $remote ) {
		$config_file = '/etc/virani.d/' . $remote;
	}
	elsif ( -f '/etc/virani.d/' . $remote . '.toml' ) {
		$config_file = '/etc/virani.d/' . $remote . '.toml';
	}

	my $toml;
	if ( defined($config_file) ) {
		print 'Config File: ' . $config_file;

		my $raw_toml = read_file($config_file) || die( 'Failed to read "' . $config_file . '"' );
		my ( $toml, $err ) = from_toml($raw_toml);
		unless ($toml) {
			die( "Error parsing '" . $config_file . "':" . $err );
		}
	}
	elsif ( $remote =~ /^[Hh][Tt][Tt][Pp][Ss]*\:\/\// ) {
		print 'URL: ' . $remote . "\n";
		$url = $remote;
	}
	else {
		die( "'" . $remote . "' does not appear to be a config file or a HTTP or HTTPS URL" );
	}

	if ( defined($apikey) ) {
		print "API key: specified via --apikey\n";
	}
	elsif ( defined( $ENV{virani_api_key} ) ) {
		print 'API key: specified via $ENV{virani_api_key}' . "\n";
		$apikey = $ENV{virani_api_key};
	}
	elsif ( defined($toml) && defined( $toml->{apikey} ) ) {
		print 'API key: specified via config file at ' . $config_file . "\n";
		$apikey = $toml->{apikey};
	}

	if ( !defined($url) ) {
		if ( defined( $toml->{url} ) ) {
			$url = $toml->{url};
		}
		else {
			die( "No url specified in '" . $config_file . "'" );
		}
	}

	my $vc = Virani::Client->new( url => $url, apikey => $apikey, verify_hostname => $verify_hostname );
	$vc->fetch(
		start    => $start_obj,
		end      => $end_obj,
		filter   => $filter,
		file     => $write,
		no_cache => $no_cache,
		verbose  => $verbose,
		set      => $set,
		type     => $type
	);
	print 'Written to ' . $write . "\n";

	exit 0;
}
